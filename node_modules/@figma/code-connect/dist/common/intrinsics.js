"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parsePropsObject = exports.intrinsicToString = exports.valueMappingToString = exports.parseIntrinsic = exports.IntrinsicKind = exports.FIGMA_CONNECT_CALL = exports.API_PREFIX = void 0;
const ts = __importStar(require("typescript"));
const parser_1 = require("../react/parser");
const compiler_1 = require("../typescript/compiler");
const compiler_2 = require("../typescript/compiler");
const compiler_3 = require("../typescript/compiler");
const parser_template_helpers_1 = require("../react/parser_template_helpers");
exports.API_PREFIX = 'figma';
exports.FIGMA_CONNECT_CALL = `${exports.API_PREFIX}.connect`;
var IntrinsicKind;
(function (IntrinsicKind) {
    IntrinsicKind["Enum"] = "enum";
    IntrinsicKind["String"] = "string";
    IntrinsicKind["Boolean"] = "boolean";
    IntrinsicKind["Instance"] = "instance";
    IntrinsicKind["Children"] = "children";
    IntrinsicKind["NestedProps"] = "nested-props";
    IntrinsicKind["ClassName"] = "className";
    IntrinsicKind["TextContent"] = "text-content";
})(IntrinsicKind || (exports.IntrinsicKind = IntrinsicKind = {}));
const Intrinsics = {};
/**
 * These functions are used to convert "intrinsic" parser types (which are calls to helper functions
 * like `Figma.boolean() in code)` to an object representing that intrinsic that we can serialize to JSON.
 *
 * Each call to `makeIntrinsic` should take a function from the {@link FigmaConnectAPI},
 * ensuring that the name of the intrinsic that we're parsing matches the name of the function
 *
 * @param staticFunctionMember
 * @param obj
 */
function makeIntrinsic(intrinsicName, obj) {
    const name = `${exports.API_PREFIX}.${intrinsicName}`;
    Intrinsics[name] = {
        match: (exp) => {
            return ts.isCallExpression(exp) && exp.getText().startsWith(name);
        },
        ...obj(name),
    };
}
makeIntrinsic('boolean', (name) => {
    return {
        parse: (exp, ctx) => {
            const figmaPropNameIdentifier = exp.arguments?.[0];
            (0, compiler_1.assertIsStringLiteral)(figmaPropNameIdentifier, ctx.sourceFile, `${name} takes at least one argument, which is the Figma property name`);
            const valueMappingArg = exp.arguments?.[1];
            let valueMapping;
            if (valueMappingArg) {
                (0, compiler_3.assertIsObjectLiteralExpression)(valueMappingArg, ctx.sourceFile, `${name} second argument should be an object literal, that sets values for 'true' and 'false'`);
                valueMapping = parsePropsObject(valueMappingArg, ctx);
            }
            return {
                kind: IntrinsicKind.Boolean,
                args: {
                    figmaPropName: (0, compiler_1.stripQuotes)(figmaPropNameIdentifier),
                    valueMapping,
                },
            };
        },
    };
});
makeIntrinsic('enum', (name) => {
    return {
        parse: (exp, ctx) => {
            const { sourceFile } = ctx;
            const figmaPropNameIdentifier = exp.arguments?.[0];
            (0, compiler_1.assertIsStringLiteral)(figmaPropNameIdentifier, sourceFile, `${name} takes at least one argument, which is the Figma property name`);
            const valueMapping = exp.arguments?.[1];
            (0, compiler_3.assertIsObjectLiteralExpression)(valueMapping, sourceFile, `${name} second argument should be an object literal, that maps Figma prop values to code`);
            return {
                kind: IntrinsicKind.Enum,
                args: {
                    figmaPropName: (0, compiler_1.stripQuotes)(figmaPropNameIdentifier),
                    valueMapping: parsePropsObject(valueMapping, ctx),
                },
            };
        },
    };
});
makeIntrinsic('string', (name) => {
    return {
        parse: (exp, ctx) => {
            const { sourceFile } = ctx;
            const figmaPropNameIdentifier = exp.arguments?.[0];
            (0, compiler_1.assertIsStringLiteral)(figmaPropNameIdentifier, sourceFile, `${name} takes at least one argument, which is the Figma property name`);
            return {
                kind: IntrinsicKind.String,
                args: {
                    figmaPropName: (0, compiler_1.stripQuotes)(figmaPropNameIdentifier),
                },
            };
        },
    };
});
makeIntrinsic('instance', (name) => {
    return {
        parse: (exp, ctx) => {
            const { sourceFile } = ctx;
            const figmaPropNameIdentifier = exp.arguments?.[0];
            (0, compiler_1.assertIsStringLiteral)(figmaPropNameIdentifier, sourceFile, `${name} takes at least one argument, which is the Figma property name`);
            return {
                kind: IntrinsicKind.Instance,
                args: {
                    figmaPropName: (0, compiler_1.stripQuotes)(figmaPropNameIdentifier),
                },
            };
        },
    };
});
makeIntrinsic('children', (name) => {
    return {
        parse: (exp, ctx) => {
            const { sourceFile } = ctx;
            const layerName = exp.arguments?.[0];
            const layers = [];
            if (ts.isStringLiteral(layerName)) {
                layers.push((0, compiler_1.stripQuotes)(layerName));
            }
            else if (ts.isArrayLiteralExpression(layerName) && layerName.elements.length > 0) {
                layerName.elements.forEach((el) => {
                    (0, compiler_1.assertIsStringLiteral)(el, sourceFile);
                    const name = (0, compiler_1.stripQuotes)(el);
                    if (name.includes('*')) {
                        throw new parser_1.ParserError(`Wildcards can not be used with an array of strings. Use a single string literal instead.`, {
                            node: layerName,
                            sourceFile,
                        });
                    }
                    layers.push((0, compiler_1.stripQuotes)(el));
                });
            }
            else {
                throw new parser_1.ParserError(`Invalid argument to ${name}, should be a string literal or an array of strings`, {
                    node: layerName,
                    sourceFile,
                });
            }
            return {
                kind: IntrinsicKind.Children,
                args: {
                    layers,
                },
            };
        },
    };
});
makeIntrinsic('nestedProps', (name) => {
    return {
        parse: (exp, ctx) => {
            const { sourceFile } = ctx;
            const layerName = exp.arguments?.[0];
            const mapping = exp.arguments?.[1];
            (0, compiler_1.assertIsStringLiteral)(layerName, sourceFile, `Invalid argument to ${name}, \`layerName\` should be a string literal`);
            (0, compiler_3.assertIsObjectLiteralExpression)(mapping, sourceFile, `Invalid argument to ${name}, \`props\` should be an object literal`);
            return {
                kind: IntrinsicKind.NestedProps,
                args: {
                    layer: (0, compiler_1.stripQuotes)(layerName),
                    props: parsePropsObject(mapping, ctx),
                },
            };
        },
    };
});
makeIntrinsic('className', (name) => {
    return {
        parse: (exp, ctx) => {
            const { sourceFile } = ctx;
            const classNameArg = exp.arguments?.[0];
            const className = [];
            (0, compiler_1.assertIsArrayLiteralExpression)(classNameArg, sourceFile, `${name} takes an array of strings`);
            classNameArg.elements.forEach((el) => {
                if (ts.isStringLiteral(el)) {
                    className.push((0, compiler_1.stripQuotes)(el));
                }
                else if (ts.isCallExpression(el)) {
                    className.push(parseIntrinsic(el, ctx));
                }
            });
            return {
                kind: IntrinsicKind.ClassName,
                args: {
                    className,
                },
            };
        },
    };
});
makeIntrinsic('textContent', (name) => {
    return {
        parse: (exp, ctx) => {
            const { sourceFile } = ctx;
            const layerNameArg = exp.arguments?.[0];
            (0, compiler_1.assertIsStringLiteral)(layerNameArg, sourceFile, `${name} takes a single argument which is the Figma layer name`);
            return {
                kind: IntrinsicKind.TextContent,
                args: {
                    layer: (0, compiler_1.stripQuotes)(layerNameArg),
                },
            };
        },
    };
});
/**
 * Parses a call expression to an intrinsic
 *
 * @param exp Expression to parse
 * @param parserContext parser context
 * @returns
 */
function parseIntrinsic(exp, parserContext) {
    for (const key in Intrinsics) {
        if (Intrinsics[key].match(exp)) {
            return Intrinsics[key].parse(exp, parserContext);
        }
    }
    throw new parser_1.ParserError(`Unknown intrinsic: ${exp.getText()}`, {
        node: exp,
        sourceFile: parserContext.sourceFile,
    });
}
exports.parseIntrinsic = parseIntrinsic;
/**
 * Replace newlines in enum values with \\n so that we don't output
 * broken JS with newlines inside the string
 */
function replaceNewlines(str) {
    return str.toString().replaceAll('\n', '\\n').replaceAll("'", "\\'");
}
function valueMappingToString(valueMapping, childLayer) {
    // For enums (and booleans with a valueMapping provided), convert the
    // value mapping to an object.
    return ('{\n' +
        Object.entries(valueMapping)
            .map(([key, value]) => {
            if (typeof value === 'boolean' ||
                typeof value === 'number' ||
                typeof value === 'undefined') {
                return `"${key}": ${value}`;
            }
            if (typeof value === 'string') {
                return `"${key}": '${replaceNewlines(value)}'`;
            }
            if ('kind' in value) {
                // Mappings can be nested, e.g. an enum value can be figma.instance(...)
                return `"${key}": ${intrinsicToString(value, childLayer)}`;
            }
            const v = replaceNewlines(value.value);
            switch (value.type) {
                case 'function':
                    return `"${key}": _fcc_function('${v}')`;
                case 'identifier':
                    return `"${key}": _fcc_identifier('${v}')`;
                case 'object':
                    return `"${key}": _fcc_object('${v}')`;
                case 'template-string':
                    return `"${key}": _fcc_templateString('${v}')`;
                case 'jsx-element':
                    return `"${key}": _fcc_jsxElement('${v}')`;
                default:
                    throw new parser_1.InternalError(`Unknown helper type: ${value}`);
            }
        })
            .join(',\n') +
        '}');
}
exports.valueMappingToString = valueMappingToString;
function intrinsicToString({ kind, args }, childLayer) {
    const selector = childLayer ?? `figma.currentLayer`;
    switch (kind) {
        case IntrinsicKind.String:
        case IntrinsicKind.Instance: {
            // Outputs:
            // `const propName = figma.properties.string('propName')`, or
            // `const propName = figma.properties.boolean('propName')`, or
            // `const propName = figma.properties.instance('propName')`
            return `${selector}.__properties__.${kind}('${args.figmaPropName}')`;
        }
        case IntrinsicKind.Boolean: {
            if (args.valueMapping) {
                const mappingString = valueMappingToString(args.valueMapping, childLayer);
                // Outputs: `const propName = figma.properties.boolean('propName', { ... mapping object from above ... })`
                return `${selector}.__properties__.boolean('${args.figmaPropName}', ${mappingString})`;
            }
            return `${selector}.__properties__.boolean('${args.figmaPropName}')`;
        }
        case IntrinsicKind.Enum: {
            const mappingString = valueMappingToString(args.valueMapping, childLayer);
            // Outputs: `const propName = figma.properties.enum('propName', { ... mapping object from above ... })`
            return `${selector}.__properties__.enum('${args.figmaPropName}', ${mappingString})`;
        }
        case IntrinsicKind.Children: {
            // Outputs: `const propName = figma.properties.children(["Layer 1", "Layer 2"])`
            return `${selector}.__properties__.children([${args.layers.map((layerName) => `"${layerName}"`).join(',')}])`;
        }
        case IntrinsicKind.ClassName: {
            // Outputs: `const propName = ['btn-base', figma.currentLayer.__properties__.enum('Size, { Large: 'btn-large' })].join(" ")`
            return `[${args.className.map((className) => (typeof className === 'string' ? `"${className}"` : `${intrinsicToString(className, childLayer)}`)).join(', ')}].filter(v => !!v).join(' ')`;
        }
        case IntrinsicKind.TextContent: {
            return `${selector}.__findChildWithCriteria__({ name: '${args.layer}', type: "TEXT" }).textContent`;
        }
        case IntrinsicKind.NestedProps: {
            throw new parser_1.ParserError(`Deeply nested props should be expressed on the root level by passing the name of the inner layer`);
        }
        default:
            throw new parser_1.InternalError(`Unknown intrinsic: ${kind}`);
    }
}
exports.intrinsicToString = intrinsicToString;
function expressionToFccEnumValue(valueNode, sourceFile) {
    if (ts.isParenthesizedExpression(valueNode)) {
        return expressionToFccEnumValue(valueNode.expression, sourceFile);
    }
    if (ts.isJsxElement(valueNode) || ts.isJsxSelfClosingElement(valueNode)) {
        return (0, parser_template_helpers_1._fcc_jsxElement)(valueNode.getText());
    }
    if (ts.isArrowFunction(valueNode) || ts.isFunctionExpression(valueNode)) {
        return (0, parser_template_helpers_1._fcc_function)(valueNode.getText());
    }
    if (ts.isObjectLiteralExpression(valueNode)) {
        return (0, parser_template_helpers_1._fcc_object)(valueNode.getText());
    }
    if (ts.isTemplateLiteral(valueNode)) {
        const str = valueNode.getText().replaceAll('`', '');
        return (0, parser_template_helpers_1._fcc_templateString)(str);
    }
    if (ts.isPropertyAccessExpression(valueNode)) {
        return (0, parser_template_helpers_1._fcc_identifier)(valueNode.getText());
    }
    // Fall back to the default conversion in `convertObjectLiteralToJs`
    return undefined;
}
/**
 * Parses the `props` field in a `figma.connect()` call, returning a mapping of
 * prop names to their respective intrinsic types
 *
 * @param objectLiteral An object literal expression
 * @param parserContext Parser context
 * @returns
 */
function parsePropsObject(objectLiteral, parserContext) {
    const { sourceFile, checker } = parserContext;
    return (0, compiler_2.convertObjectLiteralToJs)(objectLiteral, sourceFile, checker, (valueNode) => {
        if (ts.isCallExpression(valueNode)) {
            return parseIntrinsic(valueNode, parserContext);
        }
        return expressionToFccEnumValue(valueNode, sourceFile);
    });
}
exports.parsePropsObject = parsePropsObject;
//# sourceMappingURL=intrinsics.js.map