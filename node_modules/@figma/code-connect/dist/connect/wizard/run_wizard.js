"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runWizard = exports.getUnconnectedComponentsAndConnectedComponentMappings = exports.convertRemoteFileUrlToRelativePath = exports.getComponentChoicesForPrompt = void 0;
const connect_1 = require("../../commands/connect");
const prompts_1 = __importDefault(require("prompts"));
const fs_1 = __importDefault(require("fs"));
const helpers_1 = require("../helpers");
const figma_rest_api_1 = require("../figma_rest_api");
const logging_1 = require("../../common/logging");
const axios_1 = __importStar(require("axios"));
const project_1 = require("../../connect/project");
const validation_1 = require("../validation");
const chalk_1 = __importDefault(require("chalk"));
const path_1 = __importDefault(require("path"));
const parser_executable_types_1 = require("../parser_executable_types");
const create_1 = require("../create");
const create_2 = require("../../react/create");
const boxen_1 = __importDefault(require("boxen"));
const parser_1 = require("../../react/parser");
const helpers_2 = require("./helpers");
const strip_ansi_1 = __importDefault(require("strip-ansi"));
const parser_executables_1 = require("../parser_executables");
const ora_1 = __importDefault(require("ora"));
const zod_validation_error_1 = require("zod-validation-error");
const autolinking_1 = require("./autolinking");
const NONE = '(None)';
const DELIMITERS_REGEX = /[\s-_]/g;
function clearQuestion(prompt, answer) {
    const displayedAnswer = (Array.isArray(prompt.choices) && prompt.choices.find((c) => c.value === answer)?.title) ||
        answer;
    const lengthOfDisplayedQuestion = (0, strip_ansi_1.default)(prompt.message).length + (0, strip_ansi_1.default)(displayedAnswer).length + 5; // 2 chars before, 3 chars between Q + A
    const rowsToRemove = Math.ceil(lengthOfDisplayedQuestion / process.stdout.columns);
    process.stdout.moveCursor(0, -rowsToRemove);
    process.stdout.clearScreenDown();
}
async function fetchTopLevelComponentsFromFile({ accessToken, figmaUrl, }) {
    // TODO enter create flow if node-id specified
    const fileKey = (0, helpers_1.parseFileKey)(figmaUrl);
    const apiUrl = (0, figma_rest_api_1.getApiUrl)(figmaUrl ?? '') + `/code_connect/${fileKey}/cli_data`;
    try {
        const spinner = (0, ora_1.default)({
            text: 'Fetching component information from Figma...',
            color: 'green',
        }).start();
        const response = await (process.env.CODE_CONNECT_MOCK_DOC_RESPONSE
            ? Promise.resolve({
                status: 200,
                data: JSON.parse(fs_1.default.readFileSync(process.env.CODE_CONNECT_MOCK_DOC_RESPONSE, 'utf-8')),
            })
            : axios_1.default.get(apiUrl, {
                headers: {
                    'X-Figma-Token': accessToken,
                    'Content-Type': 'application/json',
                },
            })).finally(() => {
            spinner.stop();
        });
        if (response.status === 200) {
            return (0, helpers_1.findComponentsInDocument)(response.data.document).filter(({ id }) => id in response.data.componentSets || !response.data.components[id].componentSetId);
        }
        else {
            logging_1.logger.error(`Failed to fetch components from Figma with status: ${response.status}`);
            logging_1.logger.debug('Failed to fetch components from Figma with Body:', response.data);
        }
    }
    catch (err) {
        if ((0, axios_1.isAxiosError)(err)) {
            if (err.response) {
                logging_1.logger.error(`Failed to fetch components from Figma (${err.code}): ${err.response?.status} ${err.response?.data?.err ?? err.response?.data?.message}`);
            }
            else {
                logging_1.logger.error(`Failed to fetch components from Figma: ${err.message}`);
            }
            logging_1.logger.debug(JSON.stringify(err.response?.data));
        }
        (0, helpers_1.exitWithFeedbackMessage)(1);
    }
}
/**
 * Asks a Prompts question and adds spacing
 * @param question Prompts question
 * @returns Prompts answer
 */
async function askQuestion(question) {
    const answers = await (0, prompts_1.default)(question);
    logging_1.logger.info('');
    return answers;
}
/**
 * Asks a Prompts question and exits the process if user cancels
 * @param question Prompts question
 * @returns Prompts answer
 */
async function askQuestionOrExit(question) {
    const answers = await askQuestion(question);
    if (!Object.keys(answers).length) {
        return process.exit(0);
    }
    return answers;
}
/**
 * Asks a Prompts question and shows an exit confirmation if user cancels.
 * This should be used for questions further along in the wizard.
 * @param question Prompts question
 * @returns Prompts answer
 */
async function askQuestionWithExitConfirmation(question) {
    while (true) {
        const answers = await askQuestion(question);
        if (Object.keys(answers).length) {
            return answers;
        }
        const { shouldExit } = await askQuestion({
            type: 'select',
            name: 'shouldExit',
            message: 'Are you sure you want to exit?',
            choices: [
                {
                    title: 'Yes',
                    value: 'yes',
                },
                {
                    title: 'No',
                    value: 'no',
                },
            ],
        });
        // also exit if no answer provided (esc / ctrl+c)
        if (!shouldExit || shouldExit === 'yes') {
            process.exit(0);
        }
    }
}
function formatComponentTitle(componentName, path, pad) {
    const nameLabel = `${chalk_1.default.dim('Figma component:')} ${componentName.padEnd(pad, ' ')}`;
    const linkedLabel = `↔️ ${path ?? '-'}`;
    return `${nameLabel}  ${linkedLabel}`;
}
function getComponentChoicesForPrompt(components, linkedNodeIdsToPaths, connectedComponentsMappings, dir) {
    const longestNameLength = [...components, ...connectedComponentsMappings].reduce((longest, component) => Math.max(longest, 'name' in component ? component.name.length : component.componentName.length), 0);
    const nameCompare = (a, b) => a.name.localeCompare(b.name);
    const linkedComponents = components.filter((c) => !!linkedNodeIdsToPaths[c.id]).sort(nameCompare);
    const unlinkedComponents = components.filter((c) => !linkedNodeIdsToPaths[c.id]).sort(nameCompare);
    const formatComponentChoice = (c) => {
        const componentPath = linkedNodeIdsToPaths[c.id]
            ? path_1.default.relative(dir, linkedNodeIdsToPaths[c.id])
            : null;
        return {
            title: formatComponentTitle(c.name, componentPath, longestNameLength),
            value: c.id,
            description: `${chalk_1.default.green('Edit link')}`,
        };
    };
    return [
        ...linkedComponents.map(formatComponentChoice),
        ...unlinkedComponents.map(formatComponentChoice),
        ...connectedComponentsMappings.map((connectedComponent) => ({
            title: formatComponentTitle(connectedComponent.componentName, connectedComponent.path, longestNameLength),
            disabled: true,
        })),
    ];
}
exports.getComponentChoicesForPrompt = getComponentChoicesForPrompt;
function getUnconnectedComponentChoices(componentPaths, dir) {
    return [
        {
            title: NONE,
            value: NONE,
        },
        ...componentPaths.map((absPath) => {
            return {
                title: path_1.default.relative(dir, absPath),
                value: absPath,
            };
        }),
    ];
}
async function runManualLinking({ unconnectedComponents, linkedNodeIdsToPaths, componentPaths, connectedComponentsMappings, cmd, }) {
    const dir = (0, connect_1.getDir)(cmd);
    while (true) {
        // Don't show exit confirmation as we're relying on esc behavior
        const { nodeId } = await (0, prompts_1.default)({
            type: 'select',
            name: 'nodeId',
            message: `Select a link to edit (Press ${chalk_1.default.green('esc')} when you're ready to continue on)`,
            choices: getComponentChoicesForPrompt(unconnectedComponents, linkedNodeIdsToPaths, connectedComponentsMappings, dir),
            warn: 'This component already has a local Code Connect file.',
            hint: ' ',
        }, {
            onSubmit: clearQuestion,
        });
        if (!nodeId) {
            return;
        }
        const pathChoices = getUnconnectedComponentChoices(componentPaths, dir);
        const { pathToComponent } = await (0, prompts_1.default)({
            type: 'autocomplete',
            name: 'pathToComponent',
            message: 'Choose a path to your code component (type to filter results)',
            choices: pathChoices,
            // default suggest uses .startsWith(input) which isn't very useful for full paths
            suggest: (input, choices) => Promise.resolve(choices.filter((i) => i.value.toUpperCase().includes(input.toUpperCase()))),
            // preselect if editing an existing choice
            initial: nodeId in linkedNodeIdsToPaths
                ? pathChoices.findIndex(({ value }) => value === linkedNodeIdsToPaths[nodeId])
                : 0,
        }, {
            onSubmit: clearQuestion,
        });
        if (pathToComponent) {
            if (pathToComponent === NONE) {
                delete linkedNodeIdsToPaths[nodeId];
            }
            else {
                linkedNodeIdsToPaths[nodeId] = pathToComponent;
            }
        }
    }
}
async function runManualLinkingWithConfirmation(manualLinkingArgs) {
    let outDir = manualLinkingArgs.cmd.outDir || null;
    let hasAskedOutDirQuestion = false;
    while (true) {
        await runManualLinking(manualLinkingArgs);
        if (!outDir && !hasAskedOutDirQuestion) {
            const { outputDirectory } = await askQuestionWithExitConfirmation({
                type: 'text',
                name: 'outputDirectory',
                message: `What directory should Code Connect files be created in? (Press ${chalk_1.default.green('enter')} to co-locate your files alongside your component files)`,
            });
            hasAskedOutDirQuestion = true;
            outDir = outputDirectory;
        }
        const linkedNodes = Object.keys(manualLinkingArgs.linkedNodeIdsToPaths);
        if (!linkedNodes.length) {
            const { confirmation } = await askQuestionOrExit({
                type: 'select',
                name: 'confirmation',
                message: `No Code Connect files linked. Are you sure you want to exit?`,
                choices: [
                    {
                        title: 'Back to edit',
                        value: 'backToEdit',
                    },
                    {
                        title: 'Exit',
                        value: 'exit',
                    },
                ],
            });
            if (confirmation === 'exit') {
                process.exit(0);
            }
        }
        else {
            const { confirmation } = await askQuestionWithExitConfirmation({
                type: 'select',
                name: 'confirmation',
                message: `You're ready to create ${chalk_1.default.green(linkedNodes.length)} Code Connect file${linkedNodes.length == 1 ? '' : 's'}. Continue?`,
                choices: [
                    {
                        title: 'Create files',
                        value: 'create',
                    },
                    {
                        title: 'Back to editing',
                        value: 'backToEdit',
                    },
                ],
            });
            if (confirmation !== 'backToEdit') {
                return outDir;
            }
        }
    }
}
// returns ES-style import path from given system path
function formatImportPath(systemPath) {
    // use forward slashes for import paths
    let formattedImportPath = systemPath.replaceAll(path_1.default.sep, '/');
    // prefix current dir paths with ./ (node path does not)
    formattedImportPath = formattedImportPath.startsWith('.')
        ? formattedImportPath
        : `./${formattedImportPath}`;
    // assume not using ESM imports
    return formattedImportPath.replace(/\.(jsx|tsx)$/, '');
}
async function createCodeConnectFiles({ linkedNodeIdsToPaths, figmaFileUrl, unconnectedComponentsMap, outDir: outDirArg, projectInfo, }) {
    for (const [nodeId, filePath] of Object.entries(linkedNodeIdsToPaths)) {
        const urlObj = new URL(figmaFileUrl);
        urlObj.search = '';
        urlObj.searchParams.append('node-id', nodeId);
        const { name } = path_1.default.parse(filePath);
        const componentName = name.split('.')[0];
        const outDir = outDirArg || path_1.default.dirname(filePath);
        const payload = {
            mode: 'CREATE',
            destinationDir: outDir,
            component: {
                figmaNodeUrl: urlObj.toString(),
                normalizedName: (0, create_1.normalizeComponentName)(name),
                ...unconnectedComponentsMap[nodeId],
            },
            config: projectInfo.config,
        };
        let result;
        if (projectInfo.config.parser === 'react') {
            result = await (0, create_2.createReactCodeConnect)(payload);
        }
        else {
            try {
                const stdout = await (0, parser_executables_1.callParser)(
                // We use `as` because the React parser makes the types difficult
                // TODO remove once React is an executable parser
                projectInfo.config, payload, projectInfo.absPath);
                result = parser_executable_types_1.CreateResponsePayload.parse(stdout);
            }
            catch (e) {
                throw (0, zod_validation_error_1.fromError)(e);
            }
        }
        const { hasErrors } = (0, parser_executables_1.handleMessages)(result.messages);
        if (hasErrors) {
            (0, logging_1.exitWithError)('Errors encountered calling parser, exiting');
        }
        else {
            result.createdFiles.forEach((file) => {
                logging_1.logger.info((0, logging_1.success)(`Created ${file.filePath}`));
            });
        }
    }
}
function convertRemoteFileUrlToRelativePath({ remoteFileUrl, gitRootPath, dir, }) {
    if (!gitRootPath) {
        return null;
    }
    const pathWithinRepo = remoteFileUrl.replace(new RegExp(`.*?(tree|blob)/[^/]*`), '');
    if (!pathWithinRepo) {
        return null;
    }
    const absPath = path_1.default.join(gitRootPath, pathWithinRepo);
    return path_1.default.relative(dir, absPath);
}
exports.convertRemoteFileUrlToRelativePath = convertRemoteFileUrlToRelativePath;
async function getUnconnectedComponentsAndConnectedComponentMappings(cmd, figmaFileUrl, componentsFromFile, projectInfo) {
    const dir = (0, connect_1.getDir)(cmd);
    const fileKey = (0, helpers_1.parseFileKey)(figmaFileUrl);
    const codeConnectObjects = await (0, connect_1.getCodeConnectObjects)(dir, cmd, projectInfo, true);
    const connectedNodeIdsInFileToCodeConnectObjectMap = codeConnectObjects.reduce((map, codeConnectJson) => {
        const parsedNode = (0, validation_1.parseFigmaNode)(cmd, codeConnectJson, true);
        if (parsedNode && parsedNode.fileKey === fileKey) {
            map[parsedNode.nodeId] = codeConnectJson;
        }
        return map;
    }, {});
    const unconnectedComponents = [];
    const connectedComponentsMappings = [];
    const gitRootPath = (0, project_1.getGitRepoAbsolutePath)(dir);
    componentsFromFile.map((c) => {
        if (c.id in connectedNodeIdsInFileToCodeConnectObjectMap) {
            const cc = connectedNodeIdsInFileToCodeConnectObjectMap[c.id];
            const relativePath = convertRemoteFileUrlToRelativePath({
                remoteFileUrl: cc.source,
                gitRootPath,
                dir,
            });
            connectedComponentsMappings.push({
                componentName: c.name,
                path: relativePath ?? '(Unknown file)',
            });
        }
        else {
            unconnectedComponents.push(c);
        }
    });
    return {
        unconnectedComponents,
        connectedComponentsMappings,
    };
}
exports.getUnconnectedComponentsAndConnectedComponentMappings = getUnconnectedComponentsAndConnectedComponentMappings;
async function askForTopLevelDirectoryOrDetermineFromConfig({ dir, hasConfigFile, config, }) {
    let componentDirectory = null;
    while (true) {
        if (!hasConfigFile) {
            const { componentDirectory: componentDirectoryAnswer } = await askQuestionOrExit({
                type: 'text',
                message: `Which top-level directory contains the code to be connected to your Figma design system? (Press ${chalk_1.default.green('enter')} to use current directory)`,
                name: 'componentDirectory',
                format: (val) => val || process.cwd(), // should this be || dir?
                validate: (value) => {
                    if (!value) {
                        return true;
                    }
                    const isValidDir = fs_1.default.existsSync(value) && fs_1.default.lstatSync(value).isDirectory();
                    if (!isValidDir)
                        return 'Please enter a valid directory path.';
                    return true;
                },
            });
            componentDirectory = componentDirectoryAnswer;
        }
        const configToUse = componentDirectory
            ? {
                ...config,
                include: (0, helpers_2.getIncludesGlob)({
                    dir,
                    componentDirectory,
                    config,
                }),
            }
            : config;
        const spinner = (0, ora_1.default)({
            text: 'Parsing local files...',
            color: 'green',
            spinner: {
                // Don't show spinner as ts.createProgram blocks thread
                frames: [''],
            },
        }).start();
        let projectInfo = await (0, project_1.getProjectInfoFromConfig)(dir, configToUse);
        let componentPaths = projectInfo.files;
        if (projectInfo.config.parser === 'react') {
            projectInfo = (0, project_1.getReactProjectInfo)(projectInfo);
            // TODO can we do similar filtering for non-react?
            componentPaths = componentPaths.filter((f) => !(0, parser_1.isFigmaConnectFile)(projectInfo.tsProgram, f));
        }
        spinner.stop();
        if (!componentPaths.length) {
            if (hasConfigFile) {
                logging_1.logger.error('No files found. Please update the include/exclude globs in your config file and try again.');
                (0, helpers_1.exitWithFeedbackMessage)(1);
            }
            else {
                logging_1.logger.error('No files for your project type could be found in that directory. Please enter a different directory.');
            }
        }
        else {
            return {
                projectInfo,
                componentDirectory,
                componentPaths,
            };
        }
    }
}
async function runWizard(cmd) {
    logging_1.logger.info((0, boxen_1.default)(`${chalk_1.default.bold(`Welcome to ${chalk_1.default.green('Code Connect')}`)}\n\n` +
        `Follow a few simple steps to connect your Figma design system to your codebase.\n` +
        `When you're done, you'll be able to see your component code while inspecting in\n` +
        `Figma's Dev Mode.\n\n` +
        `Learn more at ${chalk_1.default.cyan('https://www.figma.com/developers/code-connect')}.\n\n` +
        `Please raise bugs or feedback at ${chalk_1.default.cyan('https://github.com/figma/code-connect/issues')}.\n\n` +
        `${chalk_1.default.red.bold('Note: ')}This process will create and modify Code Connect files. Make sure you've\n` +
        `committed necessary changes in your codebase first.`, {
        padding: 1,
        margin: 1,
        textAlignment: 'center',
    }));
    const dir = (0, connect_1.getDir)(cmd);
    const { hasConfigFile, config } = await (0, project_1.parseOrDetermineConfig)(dir, cmd.config);
    let accessToken = (0, connect_1.getAccessToken)(cmd);
    if (!accessToken) {
        const { accessTokenEntered } = await askQuestionOrExit({
            type: 'text',
            message: `No access token detected. Visit https://help.figma.com/hc/en-us/articles/8085703771159-Manage-personal-access-tokens
      for instructions on how to do this, ensuring you have both the File Content and Code Connect Write scopes \n\n  Please enter your access token:`,
            name: 'accessTokenEntered',
            validate: (value) => !!value || 'Please enter an access token.',
        });
        accessToken = accessTokenEntered;
    }
    logging_1.logger.info('');
    const { componentDirectory, projectInfo, componentPaths } = await askForTopLevelDirectoryOrDetermineFromConfig({
        dir,
        hasConfigFile,
        config,
    });
    const { figmaFileUrl } = await askQuestionOrExit({
        type: 'text',
        message: 'What is the URL of the Figma file containing your design system library?',
        name: 'figmaFileUrl',
        validate: (value) => !!(0, helpers_1.parseFileKey)(value) || 'Please enter a valid Figma file URL.',
    });
    const componentsFromFile = await fetchTopLevelComponentsFromFile({
        accessToken,
        figmaUrl: figmaFileUrl,
    });
    if (!componentsFromFile) {
        (0, helpers_1.exitWithFeedbackMessage)(1);
    }
    if (!hasConfigFile) {
        const { createConfigFile } = await askQuestionOrExit({
            type: 'select',
            name: 'createConfigFile',
            message: "It looks like you don't have a Code Connect config file. Would you like to generate one now from your provided answers?",
            choices: [
                {
                    title: 'Yes',
                    value: 'yes',
                },
                {
                    title: 'No',
                    value: 'no',
                },
            ],
        });
        if (createConfigFile === 'yes') {
            await (0, helpers_2.createCodeConnectConfig)({ dir, componentDirectory, config });
        }
    }
    const linkedNodeIdsToPaths = {};
    const { unconnectedComponents, connectedComponentsMappings } = await getUnconnectedComponentsAndConnectedComponentMappings(cmd, figmaFileUrl, componentsFromFile, projectInfo);
    (0, autolinking_1.autoLinkComponents)({
        unconnectedComponents,
        linkedNodeIdsToPaths,
        componentPaths,
    });
    logging_1.logger.info((0, boxen_1.default)(`${chalk_1.default.bold(`Connecting your components`)}\n\n` +
        `${chalk_1.default.green(`${chalk_1.default.bold(Object.keys(linkedNodeIdsToPaths).length)} ${Object.keys(linkedNodeIdsToPaths).length === 1
            ? 'component was automatically matched based on its name'
            : 'components were automatically matched based on their names'}`)}\n` +
        `${chalk_1.default.yellow(`${chalk_1.default.bold(unconnectedComponents.length)} ${unconnectedComponents.length === 1
            ? 'component has not been matched'
            : 'components have not been matched'}`)}\n\n` +
        `Match up Figma components with their code definitions. When you're finished, you\n` +
        `can specify the directory you want to create Code Connect files in.`, {
        padding: 1,
        margin: 1,
        textAlignment: 'center',
    }));
    const outDir = await runManualLinkingWithConfirmation({
        unconnectedComponents,
        connectedComponentsMappings,
        linkedNodeIdsToPaths,
        componentPaths,
        cmd,
    });
    const unconnectedComponentsMap = unconnectedComponents.reduce((map, component) => {
        map[component.id] = component;
        return map;
    }, {});
    await createCodeConnectFiles({
        linkedNodeIdsToPaths,
        unconnectedComponentsMap,
        figmaFileUrl,
        outDir,
        projectInfo,
    });
}
exports.runWizard = runWizard;
//# sourceMappingURL=run_wizard.js.map