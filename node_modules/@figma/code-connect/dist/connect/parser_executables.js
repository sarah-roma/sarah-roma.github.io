"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleMessages = exports.callParser = void 0;
const logging_1 = require("../common/logging");
const cross_spawn_1 = require("cross-spawn");
const get_swift_parser_dir_1 = require("../parser_scripts/get_swift_parser_dir");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const get_gradlew_path_1 = require("../parser_scripts/get_gradlew_path");
const temporaryInputFilePath = 'tmp/figma-code-connect-parser-input.json.tmp';
const FIRST_PARTY_PARSERS = {
    swift: {
        command: async (cwd, config, mode) => {
            return `swift run --package-path ${await (0, get_swift_parser_dir_1.getSwiftParserDir)(cwd, config.xcodeprojPath)} figma-swift`;
        },
    },
    compose: {
        command: async (cwd, config, mode) => {
            const gradlewPath = await (0, get_gradlew_path_1.getGradleWrapperPath)(cwd, config.gradleWrapperPath);
            const gradleExecutableInvocation = (0, get_gradlew_path_1.getGradleWrapperExecutablePath)(gradlewPath);
            if (mode === 'CREATE') {
                return `${gradleExecutableInvocation} -p ${gradlewPath} createCodeConnect -PfilePath=${temporaryInputFilePath} -q`;
            }
            else {
                return `${gradleExecutableInvocation} -p ${gradlewPath} parseCodeConnect -PfilePath=${temporaryInputFilePath} -q`;
            }
        },
        temporaryInputFilePath: temporaryInputFilePath,
    },
    __unit_test__: {
        command: async () => 'node parser/unit_test_parser.js',
    },
};
function getParser(config) {
    const parser = FIRST_PARTY_PARSERS[config.parser];
    if (!parser) {
        (0, logging_1.exitWithError)(`Invalid parser specified: "${config.parser}". Valid parsers are: ${Object.keys(FIRST_PARTY_PARSERS).join(', ')}.`);
    }
    return parser;
}
async function callParser(config, payload, cwd) {
    return new Promise(async (resolve, reject) => {
        try {
            const parser = getParser(config);
            const command = await parser.command(cwd, config, payload.mode);
            if (parser.temporaryInputFilePath) {
                fs_1.default.mkdirSync(path_1.default.dirname(parser.temporaryInputFilePath), { recursive: true });
                fs_1.default.writeFileSync(temporaryInputFilePath, JSON.stringify(payload));
            }
            logging_1.logger.debug(`Running parser: ${command}`);
            const commandSplit = command.split(' ');
            const child = (0, cross_spawn_1.spawn)(commandSplit[0], commandSplit.slice(1), {
                cwd,
            });
            let stdout = '';
            child.stdout.on('data', (data) => {
                stdout += data.toString();
            });
            // This handles any stderr output from the parser.
            //
            // Parsers should not generally write to stderr, and should instead return
            // an array of messages at the end of execution, but there are cases where
            // you might want to log output immediately rather than at the end of the
            // run - e.g. if the parser can take a while to compile first time, you
            // might want to inform the user immediately that it is compiling.
            //
            // To log output, the parser should write a JSON object to stderr with the
            // same structure as the `messages` response object, e.g. `{ "level":
            // "INFO", "message": "Compiling parser..." }`.
            //
            // Non-JSON output will be logged as debug messages, as this is likely to
            // be e.g. compiler output which the user doesn't need to see ordinarily.
            child.stderr.on('data', (data) => {
                const message = data.toString().trim();
                try {
                    const parsed = JSON.parse(message);
                    handleMessages([parsed]);
                }
                catch (e) {
                    logging_1.logger.debug(message);
                }
            });
            child.on('close', (code) => {
                if (code !== 0) {
                    reject(new Error(`Parser exited with code ${code}`));
                }
                else {
                    resolve(JSON.parse(stdout));
                }
                if (parser.temporaryInputFilePath) {
                    fs_1.default.unlinkSync(parser.temporaryInputFilePath);
                }
            });
            child.on('error', (e) => {
                reject(e);
            });
            if (!parser.temporaryInputFilePath) {
                child.stdin.write(JSON.stringify(payload));
                child.stdin.end();
            }
        }
        catch (e) {
            (0, logging_1.exitWithError)(`Error calling parser: ${e}, try re-running the command with --verbose for more information.`);
        }
    });
}
exports.callParser = callParser;
function handleMessages(messages) {
    let hasErrors = false;
    messages.forEach((message) => {
        switch (message.level) {
            case 'DEBUG':
                logging_1.logger.debug(message.message);
                break;
            case 'INFO':
                logging_1.logger.info(message.message);
                break;
            case 'WARN':
                logging_1.logger.warn(message.message);
                break;
            case 'ERROR':
                logging_1.logger.error(message.message);
                hasErrors = true;
                break;
        }
    });
    return { hasErrors };
}
exports.handleMessages = handleMessages;
//# sourceMappingURL=parser_executables.js.map