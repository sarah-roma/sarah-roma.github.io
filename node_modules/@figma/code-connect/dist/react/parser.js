"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = exports.getDefaultTemplate = exports.parseRenderFunction = exports.isFigmaConnectFile = exports.parseComponentMetadata = exports.InternalError = exports.ParserError = void 0;
const typescript_1 = __importDefault(require("typescript"));
const project_1 = require("../connect/project");
const logging_1 = require("../common/logging");
const compiler_1 = require("../typescript/compiler");
const intrinsics_1 = require("../common/intrinsics");
const parser_template_helpers_1 = require("./parser_template_helpers");
class ParserError extends Error {
    constructor(message, context) {
        super(message);
        this.name = 'ParserError';
        this.sourceFileName = context?.sourceFile.fileName || '';
        this.sourceFilePosition =
            context && context.node
                ? getPositionInSourceFile(context.node, context.sourceFile) || null
                : null;
    }
    toString() {
        let msg = `${(0, logging_1.highlight)((0, logging_1.error)(this.name))}: ${this.message}\n`;
        if (this.sourceFileName && this.sourceFilePosition) {
            msg += ` -> ${(0, logging_1.reset)(this.sourceFileName)}:${this.sourceFilePosition.line}:${this.sourceFilePosition.character}\n`;
        }
        return msg;
    }
    toDebugString() {
        return this.toString() + `\n ${this.stack}`;
    }
}
exports.ParserError = ParserError;
class InternalError extends ParserError {
    constructor(message) {
        super(message);
        this.name = 'InternalError';
    }
}
exports.InternalError = InternalError;
/**
 * Traverses the AST and returns the first JSX element it finds
 * @param node AST node
 * @returns
 */
function findJSXElement(node) {
    if (typescript_1.default.isJsxElement(node) || typescript_1.default.isJsxFragment(node) || typescript_1.default.isJsxSelfClosingElement(node)) {
        return node;
    }
    else {
        return typescript_1.default.forEachChild(node, findJSXElement);
    }
}
function findBlock(node) {
    if (typescript_1.default.isBlock(node)) {
        return node;
    }
    else {
        return typescript_1.default.forEachChild(node, findBlock);
    }
}
function findDescendants(node, cb) {
    const matches = [];
    function visit(node) {
        if (cb(node)) {
            matches.push(node);
        }
        typescript_1.default.forEachChild(node, visit);
    }
    visit(node);
    return matches;
}
function getPositionInSourceFile(node, sourceFile) {
    return sourceFile.getLineAndCharacterOfPosition(node.getStart(sourceFile));
}
/**
 * Walks up the AST from an assignment to find the import declaration
 */
function findParentImportDeclaration(declaration) {
    let current = declaration;
    while (current) {
        if (typescript_1.default.isImportDeclaration(current)) {
            return current;
        }
        current = current.parent;
    }
}
function getImportsOfModule(sourceFile) {
    const imports = [];
    function visit(node) {
        if (typescript_1.default.isImportDeclaration(node)) {
            imports.push(node);
        }
        typescript_1.default.forEachChild(node, visit);
    }
    visit(sourceFile);
    return imports;
}
/**
 * Finds all import statements in a file that matches the given identifiers
 *
 * @param parserContext Parser context
 * @param identifiers List of identifiers to find imports for
 * @returns
 */
function getImportsForIdentifiers({ sourceFile }, _identifiers) {
    const importDeclarations = getImportsOfModule(sourceFile);
    const imports = [];
    const identifiers = _identifiers.map((identifier) => identifier.split('.')[0]);
    for (const declaration of importDeclarations) {
        let statement = declaration.getText();
        const file = declaration.getSourceFile();
        if (declaration.importClause) {
            // Default imports
            if (declaration.importClause.name) {
                const identifier = declaration.importClause.name.text;
                if (identifiers.includes(identifier)) {
                    imports.push({
                        statement,
                        file: file.fileName,
                    });
                }
            }
            if (declaration.importClause.namedBindings) {
                const namedBindings = declaration.importClause.namedBindings;
                if (typescript_1.default.isNamedImports(namedBindings)) {
                    // Named imports (import { x, y } from 'module')
                    // filter out any unused imports from the statement the identifier belongs to
                    const elements = namedBindings.elements
                        .map((specifier) => specifier.name.text)
                        .filter((name) => identifiers.includes(name));
                    if (elements.length > 0) {
                        imports.push({
                            statement: statement.replace(/{.*}/s, `{ ${elements.join(', ')} }`),
                            file: file.fileName,
                        });
                    }
                }
                else if (typescript_1.default.isNamespaceImport(namedBindings)) {
                    // Namespace import (import * as name from 'module')
                    const identifier = namedBindings.name.text;
                    if (identifiers.includes(identifier)) {
                        imports.push({
                            statement,
                            file: file.fileName,
                        });
                    }
                }
            }
        }
    }
    return imports;
}
/**
 * Extract metadata about the referenced React component. Used by both the
 * Code Connect and Storybook commands.
 *
 * @param parserContext Parser context
 * @param componentSymbol The ts.Symbol from the metadata referencing the
 * component being documented
 * @param node The node being parsed. Used for error logging.
 * @returns Metadata object
 */
async function parseComponentMetadata(node, { checker, sourceFile, absPath }, silent) {
    let componentSymbol = checker.getSymbolAtLocation(node);
    let componentSourceFile = sourceFile;
    let component = '';
    let componentDeclaration;
    // Hacky fix for namespaced components, this probably doesn't work for storybook
    if (typescript_1.default.isPropertyAccessExpression(node)) {
        componentSymbol = checker.getSymbolAtLocation(node.expression);
        if (!componentSymbol) {
            throw new ParserError(`Could not find symbol for component ${node.expression.getText()}`, {
                sourceFile,
                node,
            });
        }
    }
    // Component declared in a different file
    if (componentSymbol &&
        componentSymbol.declarations &&
        (typescript_1.default.isImportSpecifier(componentSymbol.declarations[0]) ||
            typescript_1.default.isImportClause(componentSymbol.declarations[0]))) {
        let importDeclaration = findParentImportDeclaration(componentSymbol.declarations[0]);
        if (!importDeclaration) {
            throw new ParserError('No import statement found for component, make sure the component is imported', {
                sourceFile,
                node,
            });
        }
        // The component should be imported from another file, we need to follow the
        // aliased symbol to get the correct function definition
        if (componentSymbol.flags & typescript_1.default.SymbolFlags.Alias) {
            componentSymbol = checker.getAliasedSymbol(componentSymbol);
        }
        if (!componentSymbol || !componentSymbol.declarations) {
            if (!silent) {
                logging_1.logger.warn(`Import for ${node.getText()} could not be resolved, make sure that your \`include\` globs in \`figma.config.json\` matches the component source file (in addition to the Code Connect file). If you're using path aliases, make sure to include the same aliases in \`figma.config.json\` with the \`paths\` option.`);
            }
            return {
                source: '',
                line: 0,
                component: node.getText(),
            };
        }
        // If we haven't found the component declaration by now, it's likely because it's
        // assigned to an object/namespace, for example: `export const Button = { Primary: () => <button /> }`,
        // so we need to find the function declaration by traversing the AST in that file.
        if (!typescript_1.default.isFunctionDeclaration(componentSymbol.declarations[0])) {
            const sourceFile = componentSymbol.declarations[0].getSourceFile();
            (0, compiler_1.bfsFindNode)(sourceFile, sourceFile, (node) => {
                if ((typescript_1.default.isFunctionDeclaration(node) || typescript_1.default.isVariableDeclaration(node)) &&
                    node.name &&
                    componentSymbol?.name &&
                    node.name.getText() === componentSymbol.name) {
                    componentSymbol = checker.getSymbolAtLocation(node.name);
                    return true;
                }
                return false;
            });
        }
        componentDeclaration = componentSymbol.declarations[0];
        componentSourceFile = componentDeclaration.getSourceFile();
    }
    else {
        componentDeclaration = componentSymbol?.declarations?.[0];
    }
    const source = componentSourceFile.fileName;
    if (!source) {
        throw new InternalError(`Could not find source file for component ${component} - is this file included in the directory passed to \`figma connect <dir>\`?`);
    }
    if (!componentDeclaration) {
        throw new ParserError(`Could not find declaration for component ${component}`, {
            sourceFile,
            node,
        });
    }
    const line = getPositionInSourceFile(componentDeclaration, componentSourceFile).line;
    if (line === undefined) {
        throw new InternalError(`Could not determine line number for component ${componentDeclaration.getStart(sourceFile)}`);
    }
    return {
        source,
        line,
        component: node.getText(),
    };
}
exports.parseComponentMetadata = parseComponentMetadata;
/**
 * Checks if an AST node is a `figma.connect()` call
 *
 * @param node AST node
 * @param sourceFile Source file
 * @returns True if the node is a `figma.connect()` call
 */
function isFigmaConnectCall(node, sourceFile) {
    return (typescript_1.default.isCallExpression(node) && node.expression.getText(sourceFile).includes(intrinsics_1.FIGMA_CONNECT_CALL));
}
/**
 * Checks if a file contains Code Connect by looking for the `figma.connect()` function call
 *
 * @param program
 * @param file
 * @returns
 */
function isFigmaConnectFile(program, file) {
    // We don't support Code Connect in JSX and this throws an error if we let it proceed
    if (!file.endsWith('.tsx')) {
        return false;
    }
    const sourceFile = program.getSourceFile(file);
    if (!sourceFile) {
        throw new InternalError(`Could not find source file for ${file}`);
    }
    return (findDescendants(sourceFile, (node) => {
        if (isFigmaConnectCall(node, sourceFile)) {
            return true;
        }
        return false;
    }).length > 0);
}
exports.isFigmaConnectFile = isFigmaConnectFile;
/**
 * Parses the `links` field of a `figma.connect()` call
 *
 * @param linksArray an ArrayLiteralExpression
 * @param parserContext Parser context
 * @returns An array of link objects
 */
function parseLinks(linksArray, parserContext) {
    const { sourceFile } = parserContext;
    const links = [];
    for (const element of linksArray.elements) {
        (0, compiler_1.assertIsObjectLiteralExpression)(element, sourceFile, `'links' must be an array literal with objects of the format { name: string, url: string }`);
        const name = (0, compiler_1.parsePropertyOfType)({
            objectLiteralNode: element,
            propertyName: 'name',
            predicate: typescript_1.default.isStringLiteral,
            parserContext,
            required: true,
            errorMessage: "The 'name' property must be a string literal",
        });
        const url = (0, compiler_1.parsePropertyOfType)({
            objectLiteralNode: element,
            propertyName: 'url',
            predicate: typescript_1.default.isStringLiteral,
            parserContext,
            required: true,
            errorMessage: "The 'url' property must be a string literal",
        });
        if (name && url) {
            links.push({ name: (0, compiler_1.stripQuotes)(name), url: (0, compiler_1.stripQuotes)(url) });
        }
    }
    return links;
}
function parseVariant(variantMap, sourceFile, checker) {
    return (0, compiler_1.convertObjectLiteralToJs)(variantMap, sourceFile, checker, (valueNode) => {
        if (!typescript_1.default.isObjectLiteralElement(valueNode) &&
            !typescript_1.default.isStringLiteral(valueNode) &&
            !typescript_1.default.isNumericLiteral(valueNode) &&
            valueNode.kind !== typescript_1.default.SyntaxKind.TrueKeyword &&
            valueNode.kind !== typescript_1.default.SyntaxKind.FalseKeyword) {
            throw new ParserError(`Invalid value for variant, got: ${valueNode.getText()}`, {
                node: valueNode,
                sourceFile,
            });
        }
    });
}
/**
 * Parses the `imports` field of a `figma.connect()` call
 *
 * @param importsArray an ArrayLiteralExpression
 * @param parserContext Parser context
 * @returns An array of link objects
 */
function parseImports(importsArray, parserContext) {
    const { sourceFile } = parserContext;
    const imports = [];
    for (const element of importsArray.elements) {
        (0, compiler_1.assertIsStringLiteral)(element, sourceFile, `'imports' must be an array literal with strings`);
        imports.push((0, compiler_1.stripQuotes)(element));
    }
    return imports;
}
/**
 * Parses the render function passed to `figma.connect()`, extracting the code and
 * any import statements matching the JSX elements used in the function body
 *
 * @param exp A function or arrow function expression
 * @param parserContext Parser context
 * @param propMappings Prop mappings object as returned by parseProps
 *
 * @returns The code of the render function and a list of imports
 */
function parseRenderFunction(exp, parserContext, propMappings) {
    const { sourceFile } = parserContext;
    let exampleCode;
    if (exp.parameters.length > 1) {
        throw new ParserError(`Expected a single props parameter for the render function, got ${exp.parameters.length} parameters`, { sourceFile, node: exp });
    }
    const propsParameter = exp.parameters[0];
    // Keep track of any props which are referenced in the example so that we can
    // insert the appropriate `figma.properties` call in the JS template
    const referencedProps = new Set();
    function createPropPlaceholder({ name, node, wrapInJsxExpression = false, }) {
        let propReferenceName = name;
        // for nested prop references like `nested.prop`, we only want to look for
        // the prop mapping of `nested`, but include the full `nested.prop` in the
        // __PROP__ call
        if (name.includes('.')) {
            propReferenceName = name.split('.')[0];
        }
        const mappedProp = propMappings && propMappings[propReferenceName];
        if (!mappedProp) {
            throw new ParserError(`Could not find prop mapping for ${propReferenceName} in the props object`, {
                sourceFile,
                node,
            });
        }
        referencedProps.add(propReferenceName);
        const callExpression = typescript_1.default.factory.createCallExpression(typescript_1.default.factory.createIdentifier('__PROP__'), undefined, [typescript_1.default.factory.createStringLiteral(name)]);
        if (wrapInJsxExpression) {
            return typescript_1.default.factory.createJsxExpression(undefined, callExpression);
        }
        else {
            return callExpression;
        }
    }
    // Find all property access expressions in the function body and replace them
    // with a function call like `__PROP__("propName")`, so that we can easily
    // find them in the next step to convert them into
    // `${_fcc_renderReactProp(...)` in the template string.
    //
    // Doing it this way means we can  normalize the different ways in which props
    // can be accessed using the compiler API, which is much easier than using a
    // regex, then in the next step we can use a simple regex to convert that into
    // the template string.
    if (propsParameter) {
        exp = typescript_1.default.transform(exp, [
            (context) => (rootNode) => {
                function visit(node) {
                    // `props.` notation
                    if (typescript_1.default.isIdentifier(propsParameter.name) &&
                        typescript_1.default.isPropertyAccessExpression(node) &&
                        node.expression.getText().startsWith(propsParameter.name.getText())) {
                        // nested notation e.g `props.nested.prop`
                        if (typescript_1.default.isPropertyAccessExpression(node.expression)) {
                            const name = `${node.expression.name.getText()}.${node.name.getText()}`;
                            return createPropPlaceholder({ name, node });
                        }
                        const name = node.name.getText();
                        return createPropPlaceholder({ name, node });
                    }
                    // `props[""]` notation
                    if (typescript_1.default.isIdentifier(propsParameter.name) &&
                        typescript_1.default.isElementAccessExpression(node) &&
                        node.expression.getText().startsWith(propsParameter.name.getText()) &&
                        typescript_1.default.isStringLiteral(node.argumentExpression)) {
                        const name = (0, compiler_1.stripQuotes)(node.argumentExpression);
                        return createPropPlaceholder({ name, node });
                    }
                    // object destructuring references
                    if (typescript_1.default.isObjectBindingPattern(propsParameter.name) &&
                        typescript_1.default.isJsxExpression(node) &&
                        node.expression &&
                        propsParameter.name.elements.find((el) => node.expression?.getText().startsWith(el.name.getText()))) {
                        const name = node.expression.getText();
                        return createPropPlaceholder({ name, node, wrapInJsxExpression: true });
                    }
                    // object assignment using destructured reference, e.g `prop={{ key: value }}`
                    // (`{{ key: props.value }}` syntax will be captured by the `props.` notation branch above)
                    if (typescript_1.default.isObjectBindingPattern(propsParameter.name) &&
                        typescript_1.default.isPropertyAssignment(node) &&
                        typescript_1.default.isIdentifier(node.initializer) &&
                        propsParameter.name.elements.find((el) => node.initializer.getText().startsWith(el.name.getText()))) {
                        return typescript_1.default.factory.createPropertyAssignment(node.name, createPropPlaceholder({ name: node.initializer.getText(), node }));
                    }
                    // object assignment using destructured reference as a shorthand, e.g `prop={{ value }}`
                    if (typescript_1.default.isObjectBindingPattern(propsParameter.name) &&
                        typescript_1.default.isShorthandPropertyAssignment(node) &&
                        propsParameter.name.elements.find((el) => node.name.getText().startsWith(el.name.getText()))) {
                        return typescript_1.default.factory.createPropertyAssignment(node.name, createPropPlaceholder({ name: node.name.getText(), node }));
                    }
                    // Replaces {...props} with all the prop mapped props we know about,
                    // e.g. <Button {...props} /> becomes:
                    // <Button prop1={__PROP__("prop1")} prop2={__PROP__("prop2")} />.
                    if (typescript_1.default.isJsxSpreadAttribute(node) &&
                        typescript_1.default.isIdentifier(node.expression) &&
                        // example: (props) => (...)
                        (node.expression.getText() === propsParameter.name.getText() ||
                            // example: ({ prop1, prop2 ...props }) => (...)
                            (typescript_1.default.isObjectBindingPattern(propsParameter.name) &&
                                propsParameter.name.elements.find((el) => el.dotDotDotToken && el.name.getText() === node.expression?.getText())))) {
                        // if we have an object binding pattern ({ prop1, prop2 ...props }),
                        // exclude the props that are already destructured (prop1, prop2)
                        const propsToExclude = typescript_1.default.isObjectBindingPattern(propsParameter.name)
                            ? propsParameter.name.elements
                                .filter((el) => !el.dotDotDotToken)
                                .map((el) => el.name.getText())
                            : [];
                        const props = propMappings
                            ? Object.keys(propMappings)
                                .filter((prop) => !propsToExclude.includes(prop))
                                .map((prop) => {
                                return typescript_1.default.factory.createJsxAttribute(typescript_1.default.factory.createIdentifier(prop), createPropPlaceholder({
                                    name: prop,
                                    node,
                                    wrapInJsxExpression: true,
                                }));
                            })
                            : [];
                        if (propMappings) {
                            for (const key of Object.keys(propMappings)) {
                                referencedProps.add(key);
                            }
                        }
                        return props;
                    }
                    return typescript_1.default.visitEachChild(node, visit, context);
                }
                return typescript_1.default.visitNode(rootNode, visit);
            },
        ]).transformed[0];
    }
    const printer = typescript_1.default.createPrinter();
    const block = findBlock(exp);
    let nestable = false;
    let jsx = findJSXElement(exp);
    if (jsx && (!block || (block && block.statements.length <= 1))) {
        // The function body is a single JSX element
        exampleCode = printer.printNode(typescript_1.default.EmitHint.Unspecified, jsx, sourceFile);
        nestable = true;
    }
    else if (block) {
        // The function body has more stuff in it, so we wrap the body in a function
        // expression. Why not just print the exact function passed to `render`?
        // Because the parameters to that function are not actually referenced in
        // the rendered code snippet in Figma - they're mapped to values on the
        // Figma instance.
        const functionName = 'Example';
        const functionExpression = typescript_1.default.factory.createFunctionExpression(undefined, undefined, typescript_1.default.factory.createIdentifier(functionName), [], undefined, undefined, block);
        const printer = typescript_1.default.createPrinter();
        exampleCode = printer.printNode(typescript_1.default.EmitHint.Unspecified, functionExpression, sourceFile);
    }
    else {
        throw new ParserError(`Expected a single JSX element or a block statement in the render function, got ${exp.getText()}`, { sourceFile, node: exp });
    }
    let templateCode = '';
    // Replace React prop placeholders we inserted above (like
    // `reactPropName={__PROP__("figmaPropName")}`) with calls to
    // _fcc_renderReactProp, which renders them correctly (see
    // parser_template_helpers.ts)
    exampleCode = exampleCode.replace(
    // match " reactPropName={__PROP__("figmaPropName")}" and extract the names
    // We allow hyphens in prop names (unlike React) to support rendering HTML attributes
    / ([A-Za-z0-9\-]+)=\{__PROP__\("([A-Za-z0-9_\.]+)"\)\}/g, (_match, reactPropName, figmaPropName) => {
        return `\${_fcc_renderReactProp('${reactPropName}', ${figmaPropName})}`;
    });
    // Replace React children placeholders like `${__PROP__("propName")}` with
    // calls to _fcc_renderReactChildren, which renders them correctly (see
    // parser_template_helpers.ts)
    exampleCode = exampleCode.replace(/\{__PROP__\("([A-Za-z_\.]+)"\)\}/g, (_match, figmaPropName) => {
        return `\${_fcc_renderReactChildren(${figmaPropName})}`;
    });
    // Replace object values like `{ prop: __PROP__("propName") }` with
    // `{ prop: ${propName} }`. These never need special treatment based on their type.
    exampleCode = exampleCode.replace(/([A-Za-z0-9]+):\s+__PROP__\("([A-Za-z_\.]+)"\)/g, (_match, objectKey, figmaPropName) => {
        return `${objectKey}: \${_fcc_renderPropValue(${figmaPropName})}`;
    });
    // Generate the template code
    // Inject React-specific template helper functions
    templateCode = (0, parser_template_helpers_1.getParsedTemplateHelpersString)() + '\n\n';
    // Require the template API
    templateCode += `const figma = require('figma')\n\n`;
    let nestedLayerCount = 0;
    // Then we output `const propName = figma.properties.<kind>('propName')` calls
    // for each referenced prop, so these are accessible to the template code.
    if (propMappings && referencedProps.size > 0) {
        referencedProps.forEach((prop) => {
            const propMapping = propMappings[prop];
            if (!propMapping) {
                throw new ParserError(`Could not find prop mapping for ${prop}`, {
                    sourceFile,
                    node: exp,
                });
            }
            if (propMapping.kind === intrinsics_1.IntrinsicKind.NestedProps) {
                // the actual layer name in figma could have a bunch of special characters in it,
                // and if we try to normalize it to a valid JS identifier, it could conflict with
                // other variables in the template code. So we generate a unique variable name
                // for each nested layer reference instead.
                const nestedLayerRef = `nestedLayer${nestedLayerCount++}`;
                templateCode += `const ${nestedLayerRef} = figma.currentLayer.__find__("${propMapping.args.layer}")\n`;
                templateCode += `const ${prop} = {
${Object.entries(propMapping.args.props).map(([key, intrinsic]) => `${key}: ${(0, intrinsics_1.intrinsicToString)(intrinsic, nestedLayerRef)}\n`)}
        }\n`;
            }
            else {
                templateCode += `const ${prop} = ${(0, intrinsics_1.intrinsicToString)(propMapping)}\n`;
            }
        });
        templateCode += '\n';
    }
    // Finally, output the example code
    templateCode += `export default figma.tsx\`${exampleCode}\`\n`;
    // Find all JSX elements in the function body and extract their import
    // statements
    const jsxTags = findDescendants(exp, (element) => typescript_1.default.isJsxElement(element) || typescript_1.default.isJsxSelfClosingElement(element)).map(compiler_1.getTagName);
    const imports = getImportsForIdentifiers(parserContext, jsxTags);
    return {
        code: templateCode,
        imports,
        nestable,
    };
}
exports.parseRenderFunction = parseRenderFunction;
function followIdentifierToStringLiteralDeclaration(node, parserContext, errMessage) {
    const { checker } = parserContext;
    let result = node;
    if (node && typescript_1.default.isIdentifier(node)) {
        const symbol = checker.getSymbolAtLocation(node);
        if (symbol) {
            const decl = symbol.valueDeclaration;
            if (decl &&
                typescript_1.default.isVariableDeclaration(decl) &&
                decl.initializer &&
                typescript_1.default.isStringLiteral(decl.initializer)) {
                result = decl.initializer;
            }
        }
    }
    // If we followed the identifier to its declaration and it's not a string literal,
    // throw an error
    if (!result || !typescript_1.default.isStringLiteral(result)) {
        throw new ParserError(errMessage, {
            node: result,
            sourceFile: parserContext.sourceFile,
        });
    }
    return result;
}
function parseFigmaConnectArgs(node, parserContext) {
    const required = true;
    const first = (0, compiler_1.parseFunctionArgument)(node, parserContext, 0, (0, compiler_1.isOneOf)([typescript_1.default.isIdentifier, typescript_1.default.isPropertyAccessExpression, typescript_1.default.isStringLiteral]), required, `\`${intrinsics_1.FIGMA_CONNECT_CALL}\` must be called with a reference to a Component or a Figma Component URL as the first argument. Example usage:
  \`${intrinsics_1.FIGMA_CONNECT_CALL}(Button, 'https://www.figma.com/file/123?node-id=1-1')\``);
    let figmaNodeUrlArg;
    let componentArg;
    let configObjArgIndex;
    // This function has two signatures. If the first arg is a string literal, it's the Figma node URL, and
    // it won't have a component reference.
    if (typescript_1.default.isStringLiteral(first)) {
        figmaNodeUrlArg = first;
        componentArg = undefined;
        configObjArgIndex = 1;
    }
    else {
        // If the first argument is not a string literal, it must be a component reference,
        // and the second argument must be the Figma node URL
        componentArg = first;
        configObjArgIndex = 2;
        const invalidTypeErrorMsg = `The second argument to ${intrinsics_1.FIGMA_CONNECT_CALL}() must be a string literal (the URL of the Figma node). Example usage:
    \`${intrinsics_1.FIGMA_CONNECT_CALL}(Button, 'https://www.figma.com/file/123?node-id=1-1')\``;
        let arg = (0, compiler_1.parseFunctionArgument)(node, parserContext, 1, (0, compiler_1.isOneOf)([typescript_1.default.isIdentifier, typescript_1.default.isStringLiteral]), required, invalidTypeErrorMsg);
        figmaNodeUrlArg = followIdentifierToStringLiteralDeclaration(arg, parserContext, invalidTypeErrorMsg);
    }
    const configObjArg = (0, compiler_1.parseFunctionArgument)(node, parserContext, configObjArgIndex, typescript_1.default.isObjectLiteralExpression, false /* not required */, `The third argument to ${intrinsics_1.FIGMA_CONNECT_CALL}() must be an object literal. Example usage:
    \`${intrinsics_1.FIGMA_CONNECT_CALL}(Button, 'https://www.figma.com/file/123?node-id=1-1', { render: () => <Button /> })\``);
    return {
        componentArg,
        figmaNodeUrlArg,
        configObjArg,
    };
}
function parseConfigObjectArg(configArg, parserContext) {
    if (!configArg) {
        return {
            propsArg: undefined,
            exampleArg: undefined,
            variantArg: undefined,
            importsArg: undefined,
            linksArg: undefined,
        };
    }
    const propsArg = (0, compiler_1.parsePropertyOfType)({
        objectLiteralNode: configArg,
        propertyName: 'props',
        predicate: typescript_1.default.isObjectLiteralExpression,
        parserContext,
        required: false,
        errorMessage: `The 'props' property must be an object literal. Example usage:
      \`${intrinsics_1.FIGMA_CONNECT_CALL}(Button, 'https://www.figma.com/file/123?node-id=1-1', {
        props: {
          disabled: figma.boolean('Disabled'),
          text: figma.string('TextContent'),
        }
      })\``,
    });
    const exampleArg = (0, compiler_1.parsePropertyOfType)({
        objectLiteralNode: configArg,
        propertyName: 'example',
        predicate: (0, compiler_1.isOneOf)([typescript_1.default.isArrowFunction, typescript_1.default.isFunctionExpression]),
        parserContext,
        required: false,
        errorMessage: `The 'example' property must be an inline function or arrow function. Example usage:
    \`${intrinsics_1.FIGMA_CONNECT_CALL}(Button, 'https://www.figma.com/file/123?node-id=1-1', {
      example: () => <Button />
    })\``,
    });
    const variantArg = (0, compiler_1.parsePropertyOfType)({
        objectLiteralNode: configArg,
        propertyName: 'variant',
        predicate: typescript_1.default.isObjectLiteralExpression,
        parserContext,
        required: false,
        errorMessage: `The 'variant' property must be an object literal. Example usage:
    \`${intrinsics_1.FIGMA_CONNECT_CALL}(Button, 'https://www.figma.com/file/123?node-id=1-1', {
      variant: {
        "Has Icon": true
      }
    })\``,
    });
    const linksArg = (0, compiler_1.parsePropertyOfType)({
        objectLiteralNode: configArg,
        propertyName: 'links',
        predicate: typescript_1.default.isArrayLiteralExpression,
        parserContext,
        required: false,
        errorMessage: `The 'links' property must be an array literal. Example usage:
    \`${intrinsics_1.FIGMA_CONNECT_CALL}(Button, 'https://www.figma.com/file/123?node-id=1-1', {
      links: [
        { name: 'Storybook', url: 'https://storybook.com' }
      ]
    })\``,
    });
    const importsArg = (0, compiler_1.parsePropertyOfType)({
        objectLiteralNode: configArg,
        propertyName: 'imports',
        predicate: typescript_1.default.isArrayLiteralExpression,
        parserContext,
        required: false,
        errorMessage: `The 'imports' property must be an array literal. Example usage:
    \`${intrinsics_1.FIGMA_CONNECT_CALL}(Button, 'https://www.figma.com/file/123?node-id=1-1', {
      imports: ['import { Button } from "./Button"']
    })\``,
    });
    return {
        propsArg,
        exampleArg,
        variantArg,
        linksArg,
        importsArg,
    };
}
function getDefaultTemplate(componentMetadata) {
    const example = `<${componentMetadata.component} />`;
    return `const figma = require("figma")\n\nexport default figma.tsx\`${example}\``;
}
exports.getDefaultTemplate = getDefaultTemplate;
async function parseDoc(node, parserContext, { repoUrl, silent }) {
    const { checker, sourceFile, config } = parserContext;
    // Parse the arguments to the `Figma.connect()` call
    const { componentArg, figmaNodeUrlArg, configObjArg } = parseFigmaConnectArgs(node, parserContext);
    // The ones with ! are definitely defined because their parser fn has required: true,
    // but I couldn't work out how to model that in TypeScript
    const { propsArg, exampleArg, variantArg, linksArg, importsArg } = parseConfigObjectArg(configObjArg, parserContext);
    let figmaNode = (0, compiler_1.stripQuotes)(figmaNodeUrlArg);
    // TODO This logic is duplicated in connect.ts transformDocFromParser due to some type issues
    if (config.documentUrlSubstitutions) {
        Object.entries(config.documentUrlSubstitutions).forEach(([from, to]) => {
            figmaNode = figmaNode.replace(from, to);
        });
    }
    const metadata = componentArg
        ? await parseComponentMetadata(componentArg, parserContext, silent)
        : undefined;
    const props = propsArg ? (0, intrinsics_1.parsePropsObject)(propsArg, parserContext) : undefined;
    const render = exampleArg ? parseRenderFunction(exampleArg, parserContext, props) : undefined;
    const variant = variantArg ? parseVariant(variantArg, sourceFile, checker) : undefined;
    const links = linksArg ? parseLinks(linksArg, parserContext) : undefined;
    let resolvedImports;
    if (importsArg) {
        resolvedImports = parseImports(importsArg, parserContext);
    }
    else {
        // If no template function was provided, construct one and add the import
        // statement for the component
        let imports = render?.imports
            ? render.imports
            : metadata !== undefined
                ? getImportsForIdentifiers(parserContext, [metadata.component])
                : [];
        if (imports.length === 0 && metadata?.component) {
            // If no imports were found, it might mean that the component is not imported, or
            // that the `figma.connect` call is in the same file as the component. In the latter
            // case - we'll want to generate one
            const fileName = metadata.source.split('/').pop()?.split('.')[0];
            imports = [
                {
                    statement: `import { ${metadata.component} } from './${fileName}'`,
                    file: sourceFile.fileName,
                },
            ];
        }
        resolvedImports =
            imports.map((imp) => {
                if (config) {
                    const resolvedPath = (0, project_1.resolveImportPath)(imp.file, config);
                    if (resolvedPath) {
                        return imp.statement.replace(/['"]([\.\/a-zA-Z0-9]*)['"]/, `'${resolvedPath}'`);
                    }
                }
                return imp.statement;
            }) ?? [];
    }
    if (resolvedImports.length === 0 && metadata?.component) {
        logging_1.logger.warn(`The import statement for ${metadata.component} could not be automatically resolved, make sure the component is imported (if not colocating) and that the path mappings are correct in your figma.config.json`);
    }
    let template;
    if (render?.code) {
        template = render.code;
    }
    else if (metadata) {
        template = getDefaultTemplate(metadata);
    }
    else {
        throw new ParserError(`${intrinsics_1.FIGMA_CONNECT_CALL}() requires either a component argument or an example function`, { sourceFile, node });
    }
    return {
        figmaNode,
        label: 'React',
        language: 'typescript',
        component: metadata?.component,
        source: metadata?.source ? (0, project_1.getRemoteFileUrl)(metadata.source, repoUrl) : '',
        sourceLocation: metadata?.line !== undefined ? { line: metadata.line } : { line: -1 },
        variant,
        template,
        templateData: {
            // TODO: `props` here is currently only used for validation purposes,
            // we should eventually remove it from the JSON payload
            props,
            imports: resolvedImports,
            // If there's no render function, the default example is always nestable
            nestable: render ? render.nestable : true,
        },
        links,
        metadata: {
            cliVersion: require('../../package.json').version,
        },
    };
}
async function parse(program, file, config, absPath, parseOptions = {}) {
    const sourceFile = program.getSourceFile(file);
    if (!sourceFile) {
        throw new InternalError(`Could not find source file for ${file}`);
    }
    const parserContext = {
        checker: program.getTypeChecker(),
        sourceFile,
        config,
        absPath,
    };
    const codeConnectObjects = [];
    const nodes = [parserContext.sourceFile];
    while (nodes.length > 0) {
        const node = nodes.shift();
        if (isFigmaConnectCall(node, parserContext.sourceFile)) {
            const doc = await parseDoc(node, parserContext, parseOptions);
            if (doc) {
                codeConnectObjects.push(doc);
            }
        }
        nodes.push(...node.getChildren(parserContext.sourceFile));
    }
    if (codeConnectObjects.length === 0) {
        throw new ParserError(`Didn't find any calls to figma.connect()`, {
            sourceFile: parserContext.sourceFile,
            node: parserContext.sourceFile,
        });
    }
    return codeConnectObjects;
}
exports.parse = parse;
//# sourceMappingURL=parser.js.map